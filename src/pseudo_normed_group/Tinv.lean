import for_mathlib.normed_group_hom_equalizer
import pseudo_normed_group.CLC

open_locale classical nnreal
noncomputable theory
local attribute [instance] type_pow

namespace category_theory

theorem comm_sqโ {C} [category C] {Aโ Aโ Aโ Bโ Bโ Bโ : C}
  {fโ : Aโ โถ Bโ} {fโ : Aโ โถ Bโ} {fโ : Aโ โถ Bโ}
  {a : Aโ โถ Aโ} {a' : Aโ โถ Aโ} {b : Bโ โถ Bโ} {b' : Bโ โถ Bโ}
  (hโ : a โซ fโ = fโ โซ b) (hโ : a' โซ fโ = fโ โซ b') : (a โซ a') โซ fโ = fโ โซ b โซ b' :=
by rw [category.assoc, hโ, โ category.assoc, hโ, โ category.assoc]

end category_theory

open NormedGroup opposite Profinite pseudo_normed_group category_theory breen_deligne
open profinitely_filtered_pseudo_normed_group category_theory.limits
open normed_group_hom

namespace NormedGroup
namespace equalizer
def map {Vโ Vโ Wโ Wโ : NormedGroup} {fโ fโ gโ gโ} (ฯ : Vโ โถ Vโ) (ฯ : Wโ โถ Wโ)
  (hf : ฯ โซ fโ = fโ โซ ฯ) (hg : ฯ โซ gโ = gโ โซ ฯ) :
  of (fโ.equalizer gโ) โถ of (fโ.equalizer gโ) :=
normed_group_hom.equalizer.map _ _ hf.symm hg.symm

theorem map_congr
  {Vโ Vโ Wโ Wโ : NormedGroup} {fโ fโ gโ gโ} {ฯ : Vโ โถ Vโ} {ฯ : Wโ โถ Wโ}
  {Vโ' Vโ' Wโ' Wโ' : NormedGroup} {fโ' fโ' gโ' gโ'} {ฯ' : Vโ' โถ Vโ'} {ฯ' : Wโ' โถ Wโ'}
  {hf : ฯ โซ fโ = fโ โซ ฯ} {hg : ฯ โซ gโ = gโ โซ ฯ}
  {hf' : ฯ' โซ fโ' = fโ' โซ ฯ'} {hg' : ฯ' โซ gโ' = gโ' โซ ฯ'}
  (Hฯ : arrow.mk ฯ = arrow.mk ฯ') (Hฯ : arrow.mk ฯ = arrow.mk ฯ')
  (Hfโ : arrow.mk fโ = arrow.mk fโ') (Hfโ : arrow.mk fโ = arrow.mk fโ')
  (Hgโ : arrow.mk gโ = arrow.mk gโ') (Hgโ : arrow.mk gโ = arrow.mk gโ') :
  arrow.mk (map ฯ ฯ hf hg) = arrow.mk (map ฯ' ฯ' hf' hg') :=
by { cases Hฯ, cases Hฯ, cases Hfโ, cases Hfโ, cases Hgโ, cases Hgโ, refl }

lemma map_comp_map {Vโ Vโ Vโ Wโ Wโ Wโ : NormedGroup} {fโ fโ fโ gโ gโ gโ}
  {ฯ : Vโ โถ Vโ} {ฯ : Wโ โถ Wโ} {ฯ' : Vโ โถ Vโ} {ฯ' : Wโ โถ Wโ}
  (hf : ฯ โซ fโ = fโ โซ ฯ) (hg : ฯ โซ gโ = gโ โซ ฯ)
  (hf' : ฯ' โซ fโ = fโ โซ ฯ') (hg' : ฯ' โซ gโ = gโ โซ ฯ') :
  map ฯ ฯ hf hg โซ map ฯ' ฯ' hf' hg' =
  map (ฯ โซ ฯ') (ฯ โซ ฯ') (comm_sqโ hf hf') (comm_sqโ hg hg') :=
by { ext, refl }

@[simps obj map]
protected def F {J} [category J] {V W : J โฅค NormedGroup} (f g : V โถ W) : J โฅค NormedGroup :=
{ obj := ฮป X, of ((f.app X).equalizer (g.app X)),
  map := ฮป X Y ฯ, equalizer.map (V.map ฯ) (W.map ฯ) (f.naturality _) (g.naturality _),
  map_id' := ฮป X, by simp only [category_theory.functor.map_id]; exact equalizer.map_id,
  map_comp' := ฮป X Y Z ฯ ฯ, begin
    simp only [functor.map_comp],
    exact (map_comp_map _ _ _ _).symm
  end }

@[simps]
def map_nat {J} [category J] {Vโ Vโ Wโ Wโ : J โฅค NormedGroup}
  {fโ fโ gโ gโ} (ฯ : Vโ โถ Vโ) (ฯ : Wโ โถ Wโ)
  (hf : ฯ โซ fโ = fโ โซ ฯ) (hg : ฯ โซ gโ = gโ โซ ฯ) :
  equalizer.F fโ gโ โถ equalizer.F fโ gโ :=
{ app := ฮป X, equalizer.map (ฯ.app X) (ฯ.app X)
    (by rw [โ nat_trans.comp_app, โ nat_trans.comp_app, hf])
    (by rw [โ nat_trans.comp_app, โ nat_trans.comp_app, hg]),
  naturality' := ฮป X Y ฮฑ, by simp only [equalizer.F_map, map_comp_map, nat_trans.naturality] }

lemma map_nat_comp_map_nat {J} [category J] {Vโ Vโ Vโ Wโ Wโ Wโ : J โฅค NormedGroup}
  {fโ fโ fโ gโ gโ gโ} {ฯ : Vโ โถ Vโ} {ฯ : Wโ โถ Wโ} {ฯ' : Vโ โถ Vโ} {ฯ' : Wโ โถ Wโ}
  (hf : ฯ โซ fโ = fโ โซ ฯ) (hg : ฯ โซ gโ = gโ โซ ฯ)
  (hf' : ฯ' โซ fโ = fโ โซ ฯ') (hg' : ฯ' โซ gโ = gโ โซ ฯ') :
  map_nat ฯ ฯ hf hg โซ map_nat ฯ' ฯ' hf' hg' =
  map_nat (ฯ โซ ฯ') (ฯ โซ ฯ') (comm_sqโ hf hf') (comm_sqโ hg hg') :=
by { ext, refl }

end equalizer
end NormedGroup

universe variable u
variables (r : โโฅ0) (V : NormedGroup) [normed_with_aut r V] [fact (0 < r)]
variables (r' : โโฅ0) [fact (0 < r')] [fact (r' โค 1)]
variables (M Mโ Mโ Mโ : ProFiltPseuNormGrpWithTinv.{u} r')
variables (c cโ cโ cโ cโ cโ cโ cโ cโ : โโฅ0) (l m n : โ)
variables (f : Mโ โถ Mโ) (g : Mโ โถ Mโ)

def CLCPTinv (r : โโฅ0) (V : NormedGroup) (n : โ)
  [normed_with_aut r V] [fact (0 < r)] {A B : Profiniteแตแต} (f g : A โถ B) :
  NormedGroup :=
NormedGroup.of $ normed_group_hom.equalizer
  ((CLCP V n).map f)
  ((CLCP.T_inv r V n).app A โซ (CLCP V n).map g)

namespace CLCPTinv

def map {Aโ Bโ Aโ Bโ : Profiniteแตแต} (fโ gโ : Aโ โถ Bโ) (fโ gโ : Aโ โถ Bโ)
  (ฯ : Aโ โถ Aโ) (ฯ : Bโ โถ Bโ) (hโ : ฯ โซ fโ = fโ โซ ฯ) (hโ : ฯ โซ gโ = gโ โซ ฯ) :
  CLCPTinv r V n fโ gโ โถ CLCPTinv r V n fโ gโ :=
NormedGroup.equalizer.map ((CLCP V n).map ฯ) ((CLCP V n).map ฯ)
  (by rw [โ functor.map_comp, โ functor.map_comp, hโ]) $
by rw [โ category.assoc, (CLCP.T_inv _ _ _).naturality,
  category.assoc, category.assoc, โ functor.map_comp, โ functor.map_comp, hโ]

lemma map_norm_noninc {Aโ Bโ Aโ Bโ : Profiniteแตแต} (fโ gโ : Aโ โถ Bโ) (fโ gโ : Aโ โถ Bโ)
  (ฯ : Aโ โถ Aโ) (ฯ : Bโ โถ Bโ) (hโ hโ) :
  (CLCPTinv.map r V n fโ gโ fโ gโ ฯ ฯ hโ hโ).norm_noninc :=
equalizer.map_norm_noninc _ _ $ CLCP.map_norm_noninc _ _ _

@[simp] lemma map_id {A B : Profiniteแตแต} (f g : A โถ B) :
  map r V n f g f g (๐ A) (๐ B) rfl rfl = ๐ _ :=
begin
  simp only [map, NormedGroup.equalizer.map, category_theory.functor.map_id],
  exact equalizer.map_id,
end

lemma map_comp {Aโ Aโ Aโ Bโ Bโ Bโ : Profiniteแตแต}
  {fโ gโ : Aโ โถ Bโ} {fโ gโ : Aโ โถ Bโ} {fโ gโ : Aโ โถ Bโ}
  (ฯโ : Aโ โถ Aโ) (ฯโ : Aโ โถ Aโ) (ฯโ : Bโ โถ Bโ) (ฯโ : Bโ โถ Bโ)
  (h1 h2 h3 h4 h5 h6) :
  CLCPTinv.map r V n fโ gโ fโ gโ (ฯโ โซ ฯโ) (ฯโ โซ ฯโ) h1 h2 =
  CLCPTinv.map r V n fโ gโ fโ gโ ฯโ ฯโ h3 h4 โซ
  CLCPTinv.map r V n fโ gโ fโ gโ ฯโ ฯโ h5 h6 :=
begin
  simp only [map, NormedGroup.equalizer.map, category_theory.functor.map_comp],
  exact (equalizer.map_comp_map _ _ _ _).symm,
end

lemma map_comp_map {Aโ Aโ Aโ Bโ Bโ Bโ : Profiniteแตแต}
  {fโ gโ : Aโ โถ Bโ} {fโ gโ : Aโ โถ Bโ} {fโ gโ : Aโ โถ Bโ}
  (ฯโ : Aโ โถ Aโ) (ฯโ : Aโ โถ Aโ) (ฯโ : Bโ โถ Bโ) (ฯโ : Bโ โถ Bโ)
  (hโ hโ hโ hโ) :
  CLCPTinv.map r V n fโ gโ fโ gโ ฯโ ฯโ hโ hโ โซ
  CLCPTinv.map r V n fโ gโ fโ gโ ฯโ ฯโ hโ hโ =
  CLCPTinv.map r V n fโ gโ fโ gโ (ฯโ โซ ฯโ) (ฯโ โซ ฯโ) (comm_sqโ hโ hโ) (comm_sqโ hโ hโ) :=
(map_comp _ _ _ _ _ _ _ _ _ _ _ _ _).symm

@[simps]
protected def F {J} [category J] (r : โโฅ0) (V : NormedGroup) (n : โ)
  [normed_with_aut r V] [fact (0 < r)] {A B : J โฅค Profiniteแตแต} (f g : A โถ B) :
  J โฅค NormedGroup :=
{ obj := ฮป X, CLCPTinv r V n (f.app X) (g.app X),
  map := ฮป X Y ฯ, map _ _ _ _ _ _ _ (A.map ฯ) (B.map ฯ) (f.naturality _) (g.naturality _),
  map_id' := ฮป X, by simp only [category_theory.functor.map_id]; apply map_id,
  map_comp' := ฮป X Y Z ฯ ฯ, by simp only [functor.map_comp]; apply map_comp }

theorem F_def {J} [category J] (r : โโฅ0) (V : NormedGroup) (n : โ)
  [normed_with_aut r V] [fact (0 < r)] {A B : J โฅค Profiniteแตแต} (f g : A โถ B) :
  CLCPTinv.F r V n f g = NormedGroup.equalizer.F
    (whisker_right f (CLCP V n))
    (whisker_left A (CLCP.T_inv r V n) โซ whisker_right g (CLCP V n)) := rfl

@[simp]
def map_nat {J} [category J] {Aโ Bโ Aโ Bโ : J โฅค Profiniteแตแต} (fโ gโ : Aโ โถ Bโ) (fโ gโ : Aโ โถ Bโ)
  (ฯ : Aโ โถ Aโ) (ฯ : Bโ โถ Bโ) (hโ : ฯ โซ fโ = fโ โซ ฯ) (hโ : ฯ โซ gโ = gโ โซ ฯ) :
  CLCPTinv.F r V n fโ gโ โถ CLCPTinv.F r V n fโ gโ :=
{ app := ฮป X, map _ _ _ _ _ _ _ (ฯ.app X) (ฯ.app X)
    (by rw [โ nat_trans.comp_app, hโ, nat_trans.comp_app])
    (by rw [โ nat_trans.comp_app, hโ, nat_trans.comp_app]),
  naturality' := ฮป X Y ฮฑ, by simp only [CLCPTinv.F_map, map_comp_map, ฯ.naturality, ฯ.naturality] }

theorem map_nat_def {J} [category J] {Aโ Bโ Aโ Bโ : J โฅค Profiniteแตแต} (fโ gโ : Aโ โถ Bโ) (fโ gโ : Aโ โถ Bโ)
  (ฯ : Aโ โถ Aโ) (ฯ : Bโ โถ Bโ) (hโ : ฯ โซ fโ = fโ โซ ฯ) (hโ : ฯ โซ gโ = gโ โซ ฯ) :
  map_nat r V n fโ gโ fโ gโ ฯ ฯ hโ hโ = begin
    dsimp only [F_def],
    refine NormedGroup.equalizer.map_nat
      (whisker_right ฯ (CLCP V n))
      (whisker_right ฯ (CLCP V n))
      (by rw [โ whisker_right_comp, โ whisker_right_comp, hโ])
      (comm_sqโ _ (by rw [โ whisker_right_comp, โ whisker_right_comp, hโ])).symm,
    ext x : 2,
    simp only [nat_trans.comp_app, whisker_left_app, whisker_right_app,
      (CLCP.T_inv _ _ _).naturality],
  end := rfl

end CLCPTinv

def aux (r' c cโ : โโฅ0) [r1 : fact (r' โค 1)] [h : fact (cโ โค r' * c)] : fact (cโ โค c) :=
โจh.1.trans $ (mul_le_mul' r1.1 le_rfl).trans (by simp)โฉ

@[simps obj]
def CLCFPTinvโ (r : โโฅ0) (V : NormedGroup)
  (r' : โโฅ0) [fact (0 < r)] [fact (0 < r')] [r1 : fact (r' โค 1)] [normed_with_aut r V]
  (c cโ : โโฅ0) [fact (cโ โค r' * c)] (n : โ) : (ProFiltPseuNormGrpWithTinv r')แตแต โฅค NormedGroup :=
by haveI : fact (cโ โค c) := aux r' c cโ; exact
CLCPTinv.F r V n
  (nat_trans.op (Filtration.Tinvโ cโ c))
  (nat_trans.op (Filtration.res r' cโ c))

theorem CLCFPTinvโ_def (r : โโฅ0) (V : NormedGroup)
  (r' : โโฅ0) [fact (0 < r)] [fact (0 < r')] [r1 : fact (r' โค 1)] [normed_with_aut r V]
  (c cโ : โโฅ0) [fact (cโ โค r' * c)] (n : โ) :
  CLCFPTinvโ r V r' c cโ n = NormedGroup.equalizer.F
    (CLCFP.Tinv V r' c cโ n)
    (CLCFP.T_inv r V r' c n โซ @CLCFP.res V r' c cโ n (aux r' c cโ)) := rfl

/-- The functor that sends `M` and `c` to `V-hat((filtration M c)^n)^{Tโปยน}`,
defined by taking `Tโปยน`-invariants for two different actions by `Tโปยน`:

* The first comes from the action of `Tโปยน` on `M`.
* The second comes from the action of `Tโปยน` on `V`.

We take the equalizer of those two actions.

See the lines just above Definition 9.3 of [Analytic]. -/
def CLCFPTinv (r : โโฅ0) (V : NormedGroup) (r' : โโฅ0)
  (c : โโฅ0) (n : โ) [normed_with_aut r V] [fact (0 < r)] [fact (0 < r')] [fact (r' โค 1)] :
  (ProFiltPseuNormGrpWithTinv r')แตแต โฅค NormedGroup :=
CLCFPTinvโ r V r' c (r' * c) n

namespace CLCFPTinvโ

lemma map_norm_noninc [fact (cโ โค r' * c)] [fact (cโ โค c)]
  {Mโ Mโ} (f : Mโ โถ Mโ) : ((CLCFPTinvโ r V r' c cโ n).map f).norm_noninc :=
CLCPTinv.map_norm_noninc _ _ _ _ _ _ _ _ _ _ _

def res [fact (cโ โค r' * cโ)] [fact (cโ โค cโ)] [fact (cโ โค r' * cโ)] [fact (cโ โค cโ)]
  [fact (cโ โค cโ)] [fact (cโ โค cโ)] : CLCFPTinvโ r V r' cโ cโ n โถ CLCFPTinvโ r V r' cโ cโ n :=
CLCPTinv.map_nat r V _ _ _ _ _
  (nat_trans.op (Filtration.res _ cโ cโ))
  (nat_trans.op (Filtration.res _ cโ cโ)) rfl rfl

@[simp] lemma res_refl [fact (cโ โค r' * cโ)] [fact (cโ โค cโ)] : res r V r' cโ cโ cโ cโ n = ๐ _ :=
by { simp only [res, Filtration.res_refl, nat_trans.op_id], ext x : 2, apply CLCPTinv.map_id }

lemma res_comp_res
  [fact (cโ โค r' * cโ)] [fact (cโ โค cโ)]
  [fact (cโ โค r' * cโ)] [fact (cโ โค cโ)]
  [fact (cโ โค r' * cโ)] [fact (cโ โค cโ)]
  [fact (cโ โค cโ)] [fact (cโ โค cโ)]
  [fact (cโ โค cโ)] [fact (cโ โค cโ)]
  [fact (cโ โค cโ)] [fact (cโ โค cโ)] :
  res r V r' cโ cโ cโ cโ n โซ res r V r' cโ cโ cโ cโ n = res r V r' cโ cโ cโ cโ n :=
begin
  ext x : 2, simp only [res, nat_trans.comp_app],
  exact (CLCPTinv.map_comp _ _ _ _ _ _ _ _ _ _ _ _ _).symm
end

end CLCFPTinvโ

namespace CLCFPTinv

lemma map_norm_noninc {Mโ Mโ} (f : Mโ โถ Mโ) : ((CLCFPTinv r V r' c n).map f).norm_noninc :=
CLCFPTinvโ.map_norm_noninc _ _ _ _ _ _ _

def res [fact (cโ โค cโ)] : CLCFPTinv r V r' cโ n โถ CLCFPTinv r V r' cโ n :=
CLCFPTinvโ.res r V r' cโ _ cโ _ n

@[simp] lemma res_refl : res r V r' cโ cโ n = ๐ _ :=
CLCFPTinvโ.res_refl _ _ _ _ _ _

lemma res_comp_res [fact (cโ โค cโ)] [fact (cโ โค cโ)] [fact (cโ โค cโ)] :
  res r V r' cโ cโ n โซ res r V r' cโ cโ n = res r V r' cโ cโ n :=
CLCFPTinvโ.res_comp_res _ _ _ _ _ _ _ _ _ _

end CLCFPTinv

namespace breen_deligne

open CLCFPTinv

variables (M) {l m n}

namespace universal_map

variables (ฯ : universal_map m n)

def eval_CLCFPTinvโ
  [fact (cโ โค r' * cโ)] [fact (cโ โค r' * cโ)]
  [ฯ.suitable cโ cโ] [ฯ.suitable cโ cโ] :
  CLCFPTinvโ r V r' cโ cโ n โถ CLCFPTinvโ r V r' cโ cโ m :=
begin
  dsimp only [CLCFPTinvโ_def],
  refine NormedGroup.equalizer.map_nat (ฯ.eval_CLCFP _ _ _ _) (ฯ.eval_CLCFP _ _ _ _)
    (Tinv_comp_eval_CLCFP V r' cโ cโ cโ cโ ฯ).symm _,
  have hโ := T_inv_comp_eval_CLCFP r V r' cโ cโ ฯ,
  haveI : fact (cโ โค cโ) := aux r' _ _, haveI : fact (cโ โค cโ) := aux r' _ _,
  have hโ := res_comp_eval_CLCFP V r' cโ cโ cโ cโ ฯ,
  exact (comm_sqโ hโ hโ).symm,
end

@[simp] lemma eval_CLCFPTinvโ_zero
  [fact (cโ โค r' * cโ)] [fact (cโ โค r' * cโ)] :
  (0 : universal_map m n).eval_CLCFPTinvโ r V r' cโ cโ cโ cโ = 0 :=
by { simp only [eval_CLCFPTinvโ, eval_CLCFP_zero], ext, refl }

lemma eval_CLCFPTinvโ_comp {l m n : FreeMat} (f : l โถ m) (g : m โถ n)
  [fact (cโ โค r' * cโ)] [fact (cโ โค r' * cโ)] [fact (cโ โค r' * cโ)]
  [f.suitable cโ cโ] [f.suitable cโ cโ] [g.suitable cโ cโ] [g.suitable cโ cโ] :
  @eval_CLCFPTinvโ r V _ _ r' _ _ cโ cโ cโ cโ _ _ (f โซ g)
    _ _ (suitable.comp cโ) (suitable.comp cโ) =
  g.eval_CLCFPTinvโ r V r' cโ cโ cโ cโ โซ f.eval_CLCFPTinvโ r V r' cโ cโ cโ cโ :=
begin
  dsimp only [eval_CLCFPTinvโ, CLCFPTinvโ_def], delta id,
  simp only [NormedGroup.equalizer.map_nat_comp_map_nat],
  generalize_proofs h1 h2 h3 h4 h5 h6 h7 h8,
  revert h5 h6 h7 h8, resetI,
  have H1 : eval_CLCFP V r' cโ cโ (f โซ g) = eval_CLCFP V r' cโ cโ g โซ eval_CLCFP V r' cโ cโ f :=
    eval_CLCFP_comp V r' cโ cโ cโ g f,
  have H2 : eval_CLCFP V r' cโ cโ (f โซ g) = eval_CLCFP V r' cโ cโ g โซ eval_CLCFP V r' cโ cโ f :=
    eval_CLCFP_comp V r' cโ cโ cโ g f,
  rw [H1, H2],
  intros, refl,
end

lemma res_comp_eval_CLCFPTinvโ
  [fact (cโ โค r' * cโ)] [fact (cโ โค r' * cโ)]
  [fact (cโ โค r' * cโ)] [fact (cโ โค r' * cโ)]
  [fact (cโ โค cโ)] [fact (cโ โค cโ)] [fact (cโ โค cโ)] [fact (cโ โค cโ)]
  [fact (cโ โค cโ)] [fact (cโ โค cโ)] [fact (cโ โค cโ)] [fact (cโ โค cโ)]
  [ฯ.suitable cโ cโ] [ฯ.suitable cโ cโ]
  [ฯ.suitable cโ cโ] [ฯ.suitable cโ cโ] :
  CLCFPTinvโ.res r V r' cโ cโ cโ cโ n โซ ฯ.eval_CLCFPTinvโ r V r' cโ cโ cโ cโ =
    ฯ.eval_CLCFPTinvโ r V r' cโ cโ cโ cโ โซ CLCFPTinvโ.res r V r' cโ cโ cโ cโ m :=
begin
  dsimp only [CLCFPTinvโ.res, eval_CLCFPTinvโ, CLCFPTinvโ_def,
    CLCPTinv.map_nat_def], delta id,
  simp only [NormedGroup.equalizer.map_nat_comp_map_nat],
  congr' 1; { simp only [โ CLCFP.res_def], apply res_comp_eval_CLCFP },
end

def eval_CLCFPTinv [ฯ.suitable cโ cโ] :
  CLCFPTinv r V r' cโ n โถ CLCFPTinv r V r' cโ m :=
ฯ.eval_CLCFPTinvโ r V r' cโ _ cโ _

@[simp] lemma eval_CLCFPTinv_zero :
  (0 : universal_map m n).eval_CLCFPTinv r V r' cโ cโ = 0 :=
by apply eval_CLCFPTinvโ_zero

lemma eval_CLCFPTinv_comp {l m n : FreeMat} (f : l โถ m) (g : m โถ n)
  [hg : g.suitable cโ cโ] [hf : f.suitable cโ cโ] :
  @eval_CLCFPTinv r V _ _ r' _ _ cโ cโ _ _ (f โซ g) (suitable.comp cโ) =
    g.eval_CLCFPTinv r V r' cโ cโ โซ f.eval_CLCFPTinv r V r' cโ cโ :=
by apply eval_CLCFPTinvโ_comp

lemma res_comp_eval_CLCFPTinv
  [fact (cโ โค cโ)] [ฯ.suitable cโ cโ] [ฯ.suitable cโ cโ] [fact (cโ โค cโ)] :
  res r V r' cโ cโ n โซ ฯ.eval_CLCFPTinv r V r' cโ cโ =
    ฯ.eval_CLCFPTinv r V r' cโ cโ โซ res r V r' cโ cโ m :=
by apply res_comp_eval_CLCFPTinvโ

end universal_map

end breen_deligne
