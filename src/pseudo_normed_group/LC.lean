import pseudo_normed_group.FiltrationPow
import locally_constant.NormedGroup
import locally_constant.Vhat
import for_mathlib.preadditive_category

namespace category_theory
namespace nat_trans

@[simp] lemma op_comp {C D} [category C] [category D]
  {F G H : C ‚•§ D} {Œ± : F ‚ü∂ G} {Œ≤ : G ‚ü∂ H} :
  nat_trans.op (Œ± ‚â´ Œ≤) = nat_trans.op Œ≤ ‚â´ nat_trans.op Œ± := rfl

end nat_trans
end category_theory

open_locale classical nnreal big_operators
noncomputable theory
local attribute [instance] type_pow

open NormedGroup opposite Profinite pseudo_normed_group category_theory breen_deligne
open profinitely_filtered_pseudo_normed_group

universe variable u
variables (r : ‚Ñù‚â•0) (V : NormedGroup) (r' : ‚Ñù‚â•0)
variables (c c‚ÇÅ c‚ÇÇ c‚ÇÉ c‚ÇÑ : ‚Ñù‚â•0) (l m n : ‚Ñï)

/-- The functor that sends `A` to `V(A^n)` -/
def LCP (V : NormedGroup) (n : ‚Ñï) : Profinite·µí·µñ ‚•§ NormedGroup :=
(Pow n).op ‚ãô LocallyConstant.obj V

namespace LCP

lemma map_norm_noninc {M‚ÇÅ M‚ÇÇ} (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) : ((LCP V n).map f).norm_noninc :=
locally_constant.comap_hom_norm_noninc _ _

@[simps {fully_applied := ff}]
def T_inv [normed_with_aut r V] [fact (0 < r)] : LCP V n ‚ü∂ LCP V n :=
(whisker_left _ (LocallyConstant.map (normed_with_aut.T.inv : V ‚ü∂ V)) : _)

end LCP

/-- The "functor" that sends `M` and `c` to `V((filtration M c)^n)` -/
def LCFP (V : NormedGroup) (r' : ‚Ñù‚â•0) (c : ‚Ñù‚â•0) (n : ‚Ñï) :
  (ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ NormedGroup :=
((Filtration r').obj c).op ‚ãô LCP V n

theorem LCFP_def (V : NormedGroup) (r' : ‚Ñù‚â•0) (c : ‚Ñù‚â•0) (n : ‚Ñï) :
  LCFP V r' c n = (FiltrationPow r' c n).op ‚ãô LocallyConstant.obj V := rfl

namespace LCFP

lemma map_norm_noninc {M‚ÇÅ M‚ÇÇ} (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) : ((LCFP V r' c n).map f).norm_noninc :=
LCP.map_norm_noninc _ _ _

@[simps {fully_applied := ff}]
def res (r' : ‚Ñù‚â•0) (c‚ÇÅ c‚ÇÇ : ‚Ñù‚â•0) [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] (n : ‚Ñï) : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ n :=
(whisker_right (nat_trans.op (FiltrationPow.cast_le r' c‚ÇÇ c‚ÇÅ n)) (LocallyConstant.obj V) : _)

@[simp] lemma res_refl : res V r' c c n = ùüô _ :=
by { simp [res, FiltrationPow.cast_le_refl], refl }

lemma res_comp_res [h‚ÇÅ : fact (c‚ÇÉ ‚â§ c‚ÇÇ)] [h‚ÇÇ : fact (c‚ÇÇ ‚â§ c‚ÇÅ)] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ res V r' c‚ÇÇ c‚ÇÉ n = @res V r' c‚ÇÅ c‚ÇÉ ‚ü®le_trans h‚ÇÅ.1 h‚ÇÇ.1‚ü© n :=
by simp only [res, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp, FiltrationPow.cast_le_comp]

lemma res_app [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] (M) :
  (res V r' c‚ÇÅ c‚ÇÇ n).app M =
    (LCP V n).map (Filtration.cast_le (unop M : ProFiltPseuNormGrpWithTinv r') c‚ÇÇ c‚ÇÅ).op :=
rfl

lemma res_norm_noninc [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] (M) : ((res V r' c‚ÇÅ c‚ÇÇ n).app M).norm_noninc :=
locally_constant.comap_hom_norm_noninc _ _

section Tinv
open profinitely_filtered_pseudo_normed_group_with_Tinv
variables [fact (0 < r')]

@[simps {fully_applied := ff}]
def Tinv [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ n :=
(whisker_right (nat_trans.op $ FiltrationPow.Tinv r' c‚ÇÇ c‚ÇÅ n) (LocallyConstant.obj V) : _)

lemma Tinv_def [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] : Tinv V r' c‚ÇÅ c‚ÇÇ n =
  whisker_right (nat_trans.op $ Filtration.Tinv‚ÇÄ c‚ÇÇ c‚ÇÅ) (LCP V n) := rfl

lemma res_comp_Tinv
  [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] [fact (c‚ÇÉ ‚â§ c‚ÇÇ)] [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] [fact (c‚ÇÉ ‚â§ r' * c‚ÇÇ)] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ Tinv V r' c‚ÇÇ c‚ÇÉ n = Tinv V r' c‚ÇÅ c‚ÇÇ n ‚â´ res V r' c‚ÇÇ c‚ÇÉ n :=
begin
  simp only [Tinv, res, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp],
  refl
end

lemma Tinv_norm_noninc [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] (M) : ((Tinv V r' c‚ÇÅ c‚ÇÇ n).app M).norm_noninc :=
locally_constant.comap_hom_norm_noninc _ _

end Tinv

section normed_with_aut

variables [normed_with_aut r V]

instance _root_.LCP.obj.normed_with_aut (A : Profinite·µí·µñ) [fact (0 < r)] :
  normed_with_aut r ((LCP V n).obj A) :=
NormedGroup.normed_with_aut_LocallyConstant _ _ _

instance [fact (0 < r)] (M) : normed_with_aut r ((LCFP V r' c n).obj M) :=
LCP.obj.normed_with_aut _ _ _ _

@[simps app_apply {fully_applied := ff}]
def T_inv [fact (0 < r)] : LCFP V r' c n ‚ü∂ LCFP V r' c n :=
(whisker_left _ (LCP.T_inv r V n) : _)

lemma T_inv_def [fact (0 < r)] :
  T_inv r V r' c n = (whisker_left  (FiltrationPow r' c n).op
      (LocallyConstant.map (normed_with_aut.T.inv : V ‚ü∂ V)) : _) :=
rfl

lemma T_inv_app [fact (0 < r)] (M : (ProFiltPseuNormGrpWithTinv r')·µí·µñ) :
  (T_inv r V r' c n).app M =
    (LCP.T_inv r V n).app (((Filtration r').obj c).op.obj M) :=
rfl

-- This does not apply to our situation
-- lemma T_inv_norm_noninc [fact (0 < r)] : (@T_inv r V r' M _ c n _ _).norm_noninc :=
-- begin
--   refine locally_constant.map_hom_norm_noninc _,
--   -- factor this out
--   intro v,
-- end

variables [fact (0 < r)]

lemma res_comp_T_inv [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ T_inv r V r' c‚ÇÇ n = T_inv r V r' c‚ÇÅ n ‚â´ res V r' c‚ÇÅ c‚ÇÇ n :=
begin
  ext M : 2,
  simp only [nat_trans.comp_app, res_app, T_inv_app],
  exact (LCP.T_inv r V n).naturality _,
end

end normed_with_aut

end LCFP

namespace breen_deligne

open LCFP

variables {l m n}

namespace basic_universal_map

variables (œï : basic_universal_map m n)

def eval_LCFP (c‚ÇÅ c‚ÇÇ : ‚Ñù‚â•0) [œï.suitable c‚ÇÇ c‚ÇÅ] : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
(whisker_right (nat_trans.op $ œï.eval_FP r' c‚ÇÇ c‚ÇÅ) (LocallyConstant.obj V) : _)

def eval_LCFP' (c‚ÇÅ c‚ÇÇ : ‚Ñù‚â•0) : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
if H : œï.suitable c‚ÇÇ c‚ÇÅ
then by exactI (whisker_right (nat_trans.op $ œï.eval_FP r' c‚ÇÇ c‚ÇÅ) (LocallyConstant.obj V) : _)
else 0

lemma eval_LCFP_eq_eval_LCFP' (h : œï.suitable c‚ÇÇ c‚ÇÅ) :
  œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ = œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
by { delta eval_LCFP eval_LCFP', rw dif_pos h }

lemma eval_LCFP'_def [h : œï.suitable c‚ÇÇ c‚ÇÅ] :
  œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ =
    (whisker_right (nat_trans.op $ œï.eval_FP r' c‚ÇÇ c‚ÇÅ) (LocallyConstant.obj V) : _) :=
dif_pos h

lemma eval_LCFP'_not_suitable (h : ¬¨ œï.suitable c‚ÇÇ c‚ÇÅ) :
  œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ = 0 :=
dif_neg h

lemma eval_LCFP'_comp (f : basic_universal_map m n) (g : basic_universal_map l m)
  [hf : f.suitable c‚ÇÇ c‚ÇÅ] [hg : g.suitable c‚ÇÉ c‚ÇÇ] :
  (f.comp g).eval_LCFP' V r' c‚ÇÅ c‚ÇÉ = f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ ‚â´ g.eval_LCFP' V r' c‚ÇÇ c‚ÇÉ :=
begin
  haveI : (f.comp g).suitable c‚ÇÉ c‚ÇÅ := suitable_comp c‚ÇÇ,
  simp only [eval_LCFP'_def, eval_FP_comp r' _ c‚ÇÇ, nat_trans.op_comp, whisker_right_comp]
end

lemma eval_LCFP_comp (f : basic_universal_map m n) (g : basic_universal_map l m)
  [hf : f.suitable c‚ÇÇ c‚ÇÅ] [hg : g.suitable c‚ÇÉ c‚ÇÇ] :
  @eval_LCFP V r' _ _ (f.comp g) c‚ÇÅ c‚ÇÉ (suitable_comp c‚ÇÇ) =
    f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ g.eval_LCFP V r' c‚ÇÇ c‚ÇÉ :=
by { simp only [eval_LCFP_eq_eval_LCFP'], apply eval_LCFP'_comp }

lemma res_comp_eval_LCFP
  [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ c‚ÇÉ)] [œï.suitable c‚ÇÑ c‚ÇÇ] [œï.suitable c‚ÇÉ c‚ÇÅ] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ res V r' c‚ÇÉ c‚ÇÑ m :=
by simp only [res, eval_LCFP, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp,
  cast_le_comp_eval_FP _ c‚ÇÑ c‚ÇÉ c‚ÇÇ c‚ÇÅ]

lemma Tinv_comp_eval_LCFP [fact (0 < r')] [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ r' * c‚ÇÉ)]
  [œï.suitable c‚ÇÑ c‚ÇÇ] [œï.suitable c‚ÇÉ c‚ÇÅ] :
  Tinv V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ Tinv V r' c‚ÇÉ c‚ÇÑ m :=
by simp only [Tinv, eval_LCFP, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp,
  Tinv_comp_eval_FP _ _ c‚ÇÑ c‚ÇÉ c‚ÇÇ c‚ÇÅ]

lemma T_inv_comp_eval_LCFP [normed_with_aut r V] [fact (0 < r)] [œï.suitable c‚ÇÇ c‚ÇÅ] :
  T_inv r V r' c‚ÇÅ n ‚â´ œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ T_inv r V r' c‚ÇÇ m :=
begin
  ext M : 2,
  simp only [T_inv_def, eval_LCFP, nat_trans.comp_app,  whisker_right_app, whisker_left_app,
    nat_trans.naturality]
end

end basic_universal_map

namespace universal_map

open free_abelian_group

variables (œï : universal_map m n)

def eval_LCFP [œï.suitable c‚ÇÇ c‚ÇÅ] : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
‚àë g : {g : basic_universal_map m n // g ‚àà œï.support},
  begin
    haveI := suitable_of_mem_support œï c‚ÇÇ c‚ÇÅ g g.2,
    exact coeff (g : basic_universal_map m n) œï ‚Ä¢ (basic_universal_map.eval_LCFP V r' g c‚ÇÅ c‚ÇÇ)
  end

def eval_LCFP' : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
‚àë g in œï.support, coeff g œï ‚Ä¢ (g.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ)

lemma eval_LCFP_eq_eval_LCFP' (h : œï.suitable c‚ÇÇ c‚ÇÅ) :
  œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ = œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
begin
  simp only [eval_LCFP, eval_LCFP', basic_universal_map.eval_LCFP_eq_eval_LCFP',
    subtype.val_eq_coe],
  symmetry,
  apply finset.sum_subtype œï.support (Œª _, iff.rfl),
end

@[simp] lemma eval_LCFP'_of (f : basic_universal_map m n) :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (of f) = f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
begin
  simp only [eval_LCFP', support_of, coeff_of_self, one_smul, finset.sum_singleton]
end

@[simp] lemma eval_LCFP'_zero :
  (0 : universal_map m n).eval_LCFP' V r' c‚ÇÅ c‚ÇÇ = 0 :=
by rw [eval_LCFP', support_zero, finset.sum_empty]

@[simp] lemma eval_LCFP_zero :
  (0 : universal_map m n).eval_LCFP V r' c‚ÇÅ c‚ÇÇ = 0 :=
by rw [eval_LCFP_eq_eval_LCFP', eval_LCFP'_zero]

@[simp] lemma eval_LCFP'_neg (f : universal_map m n) :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (-f) = -f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
by simp only [eval_LCFP', add_monoid_hom.map_neg, finset.sum_neg_distrib, neg_smul, support_neg]

@[simp] lemma eval_LCFP_neg (f : universal_map m n) [f.suitable c‚ÇÇ c‚ÇÅ] :
  eval_LCFP V r' c‚ÇÅ c‚ÇÇ (-f) = -f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ :=
by simp only [eval_LCFP_eq_eval_LCFP', eval_LCFP'_neg]

lemma eval_LCFP'_add (f g : universal_map m n) :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (f + g) = f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ + g.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
begin
  simp only [eval_LCFP'],
  rw finset.sum_subset (support_add f g), -- two goals
  simp only [add_monoid_hom.map_add _ f g, add_smul],
  convert finset.sum_add_distrib using 2, -- three goals
  apply finset.sum_subset (finset.subset_union_left _ _), swap,
  apply finset.sum_subset (finset.subset_union_right _ _),
  all_goals { rintros x - h, rw not_mem_support_iff at h, simp [h] },
end

lemma eval_LCFP_add (f g : universal_map m n) [f.suitable c‚ÇÇ c‚ÇÅ] [g.suitable c‚ÇÇ c‚ÇÅ] :
  eval_LCFP V r' c‚ÇÅ c‚ÇÇ (f + g) = f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ + g.eval_LCFP V r' c‚ÇÅ c‚ÇÇ :=
by simp only [eval_LCFP_eq_eval_LCFP', eval_LCFP'_add]

lemma eval_LCFP'_comp_of (g : basic_universal_map m n) (f : basic_universal_map l m)
  [hg : g.suitable c‚ÇÇ c‚ÇÅ] [hf : f.suitable c‚ÇÉ c‚ÇÇ] :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÉ ((comp (of g)) (of f)) =
    eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (of g) ‚â´ eval_LCFP' V r' c‚ÇÇ c‚ÇÉ (of f) :=
begin
  simp only [comp_of, eval_LCFP'_of],
  haveI hfg : (g.comp f).suitable c‚ÇÉ c‚ÇÅ := basic_universal_map.suitable_comp c‚ÇÇ,
  rw ‚Üê basic_universal_map.eval_LCFP'_comp,
end

open category_theory category_theory.limits category_theory.preadditive

lemma eval_LCFP'_comp (g : universal_map m n) (f : universal_map l m)
  [hg : g.suitable c‚ÇÇ c‚ÇÅ] [hf : f.suitable c‚ÇÉ c‚ÇÇ] :
  (comp g f).eval_LCFP' V r' c‚ÇÅ c‚ÇÉ = g.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ ‚â´ f.eval_LCFP' V r' c‚ÇÇ c‚ÇÉ :=
begin
  unfreezingI { revert hf },
  apply free_abelian_group.induction_on_free_predicate
    (suitable c‚ÇÇ c‚ÇÅ) (suitable_free_predicate c‚ÇÇ c‚ÇÅ) g hg; unfreezingI { clear_dependent g },
  { intros h‚ÇÇ,
    simp only [eval_LCFP'_zero, zero_comp, pi.zero_apply,
      add_monoid_hom.coe_zero, add_monoid_hom.map_zero] },
  { intros g hg hf,
    -- now do another nested induction on `f`
    apply free_abelian_group.induction_on_free_predicate
      (suitable c‚ÇÉ c‚ÇÇ) (suitable_free_predicate c‚ÇÉ c‚ÇÇ) f hf; unfreezingI { clear_dependent f },
    { simp only [eval_LCFP'_zero, comp_zero, add_monoid_hom.map_zero] },
    { intros f hf,
      rw suitable_of_iff at hf,
      resetI,
      apply eval_LCFP'_comp_of },
    { intros f hf IH,
      simp only [IH, eval_LCFP'_neg, add_monoid_hom.map_neg, comp_neg] },
    { rintros (f‚ÇÅ : universal_map l m) (f‚ÇÇ : universal_map l m) hf‚ÇÅ hf‚ÇÇ IH‚ÇÅ IH‚ÇÇ, resetI,
      haveI Hg‚ÇÅf : (comp (of g) f‚ÇÅ).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
      haveI Hg‚ÇÇf : (comp (of g) f‚ÇÇ).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
      simp only [add_monoid_hom.map_add, eval_LCFP'_add, IH‚ÇÅ, IH‚ÇÇ, comp_add] } },
  { intros g hg IH hf, resetI, specialize IH,
    simp only [IH, add_monoid_hom.map_neg, eval_LCFP'_neg,
      add_monoid_hom.neg_apply, neg_inj, neg_comp] },
  { rintros (g‚ÇÅ : universal_map m n) (g‚ÇÇ : universal_map m n) hg‚ÇÅ hg‚ÇÇ IH‚ÇÅ IH‚ÇÇ hf, resetI,
    haveI Hg‚ÇÅf : (comp g‚ÇÅ f).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
    haveI Hg‚ÇÇf : (comp g‚ÇÇ f).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
    simp only [add_monoid_hom.map_add, add_monoid_hom.add_apply, eval_LCFP'_add, IH‚ÇÅ, IH‚ÇÇ, add_comp] }
end

lemma eval_LCFP_comp (g : universal_map m n) (f : universal_map l m)
  [hg : g.suitable c‚ÇÇ c‚ÇÅ] [hf : f.suitable c‚ÇÉ c‚ÇÇ] :
  @eval_LCFP V r' c‚ÇÅ c‚ÇÉ _ _ (comp g f) (suitable.comp c‚ÇÇ) =
    g.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ f.eval_LCFP V r' c‚ÇÇ c‚ÇÉ :=
by { simp only [eval_LCFP_eq_eval_LCFP'], apply eval_LCFP'_comp }

-- lemma map_comp_eval_LCFP [œï.suitable c‚ÇÅ c‚ÇÇ] :
--   map V r' c‚ÇÇ n f ‚â´ œï.eval_LCFP V r' M‚ÇÅ c‚ÇÅ c‚ÇÇ = œï.eval_LCFP V r' M‚ÇÇ c‚ÇÅ c‚ÇÇ ‚â´ map V r' c‚ÇÅ m f :=
-- begin
--   show normed_group_hom.comp_hom _ _ = normed_group_hom.comp_hom _ _,
--   simp only [eval_LCFP_def, add_monoid_hom.map_sum, add_monoid_hom.sum_apply],
--   apply finset.sum_congr rfl,
--   intros g hg,
--   haveI : g.suitable c‚ÇÅ c‚ÇÇ := suitable_of_mem_support œï c‚ÇÅ c‚ÇÇ g hg,
--   simp only [‚Üê gsmul_eq_smul, add_monoid_hom.map_gsmul, add_monoid_hom.gsmul_apply],
--   congr' 1,
--   exact g.map_comp_eval_LCFP V r' _ _ _
-- end

lemma res_comp_eval_LCFP [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ c‚ÇÉ)] [œï.suitable c‚ÇÉ c‚ÇÅ] [œï.suitable c‚ÇÑ c‚ÇÇ] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ res V r' c‚ÇÉ c‚ÇÑ m :=
begin
  simp only [eval_LCFP, comp_sum, sum_comp],
  apply finset.sum_congr rfl,
  rintros ‚ü®g, hg‚ü© -,
  -- instead of this crazy `show`, we shoul prove `comp_gsmul` and `gsmul_comp`
  -- for preadditive categories
  show @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ NormedGroup) _ _ _ _ _ _ _ =
    @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ NormedGroup) _ _ _ _ _ _ _,
  simp only [‚Üê gsmul_eq_smul, add_monoid_hom.map_gsmul, add_monoid_hom.gsmul_apply],
  haveI : g.suitable c‚ÇÉ c‚ÇÅ := suitable_of_mem_support œï _ _ g hg,
  haveI : g.suitable c‚ÇÑ c‚ÇÇ := suitable_of_mem_support œï _ _ g hg,
  congr' 1,
  apply g.res_comp_eval_LCFP V r' c‚ÇÅ c‚ÇÇ c‚ÇÉ c‚ÇÑ
end

lemma Tinv_comp_eval_LCFP [fact (0 < r')] [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ r' * c‚ÇÉ)]
  [œï.suitable c‚ÇÉ c‚ÇÅ] [œï.suitable c‚ÇÑ c‚ÇÇ] :
  Tinv V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ Tinv V r' c‚ÇÉ c‚ÇÑ m :=
begin
  simp only [eval_LCFP, comp_sum, sum_comp],
  apply finset.sum_congr rfl,
  rintros ‚ü®g, hg‚ü© -,
  show @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ NormedGroup) _ _ _ _ _ _ _ =
    @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ NormedGroup) _ _ _ _ _ _ _,
  simp only [‚Üê gsmul_eq_smul, add_monoid_hom.map_gsmul, add_monoid_hom.gsmul_apply],
  haveI : g.suitable c‚ÇÉ c‚ÇÅ := suitable_of_mem_support œï _ _ g hg,
  haveI : g.suitable c‚ÇÑ c‚ÇÇ := suitable_of_mem_support œï _ _ g hg,
  congr' 1,
  apply basic_universal_map.Tinv_comp_eval_LCFP V r'
end

lemma T_inv_comp_eval_LCFP [normed_with_aut r V] [fact (0 < r)] [œï.suitable c‚ÇÇ c‚ÇÅ] :
  T_inv r V r' c‚ÇÅ n ‚â´ œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ =
    œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ T_inv r V r' c‚ÇÇ m :=
begin
  simp only [eval_LCFP, comp_sum, sum_comp],
  apply finset.sum_congr rfl,
  rintros ‚ü®g, hg‚ü© -,
  show @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ NormedGroup) _ _ _ _ _ _ _ =
    @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ NormedGroup) _ _ _ _ _ _ _,
  simp only [‚Üê gsmul_eq_smul, add_monoid_hom.map_gsmul, add_monoid_hom.gsmul_apply],
  haveI : g.suitable c‚ÇÇ c‚ÇÅ := suitable_of_mem_support œï _ _ g hg,
  congr' 1,
  apply basic_universal_map.T_inv_comp_eval_LCFP r V r'
end

end universal_map

end breen_deligne
